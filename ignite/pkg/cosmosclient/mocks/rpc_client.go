// Code generated by mockery v2.46.0. DO NOT EDIT.

package mocks

import (
	bytes "github.com/cometbft/cometbft/libs/bytes"
	client "github.com/cometbft/cometbft/rpc/client"

	context "context"

	coretypes "github.com/cometbft/cometbft/rpc/core/types"

	log "github.com/cometbft/cometbft/libs/log"

	mock "github.com/stretchr/testify/mock"

	types "github.com/cometbft/cometbft/types"
)

// RPCClient is an autogenerated mock type for the Client type
type RPCClient struct {
	mock.Mock
}

type RPCClient_Expecter struct {
	mock *mock.Mock
}

func (_m *RPCClient) EXPECT() *RPCClient_Expecter {
	return &RPCClient_Expecter{mock: &_m.Mock}
}

// ABCIInfo provides a mock function with given fields: _a0
func (_m *RPCClient) ABCIInfo(_a0 context.Context) (*coretypes.ResultABCIInfo, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for ABCIInfo")
	}

	var r0 *coretypes.ResultABCIInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*coretypes.ResultABCIInfo, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *coretypes.ResultABCIInfo); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultABCIInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RPCClient_ABCIInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ABCIInfo'
type RPCClient_ABCIInfo_Call struct {
	*mock.Call
}

// ABCIInfo is a helper method to define mock.On call
//   - _a0 context.Context
func (_e *RPCClient_Expecter) ABCIInfo(_a0 interface{}) *RPCClient_ABCIInfo_Call {
	return &RPCClient_ABCIInfo_Call{Call: _e.mock.On("ABCIInfo", _a0)}
}

func (_c *RPCClient_ABCIInfo_Call) Run(run func(_a0 context.Context)) *RPCClient_ABCIInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *RPCClient_ABCIInfo_Call) Return(_a0 *coretypes.ResultABCIInfo, _a1 error) *RPCClient_ABCIInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RPCClient_ABCIInfo_Call) RunAndReturn(run func(context.Context) (*coretypes.ResultABCIInfo, error)) *RPCClient_ABCIInfo_Call {
	_c.Call.Return(run)
	return _c
}

// ABCIQuery provides a mock function with given fields: ctx, path, data
func (_m *RPCClient) ABCIQuery(ctx context.Context, path string, data bytes.HexBytes) (*coretypes.ResultABCIQuery, error) {
	ret := _m.Called(ctx, path, data)

	if len(ret) == 0 {
		panic("no return value specified for ABCIQuery")
	}

	var r0 *coretypes.ResultABCIQuery
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, bytes.HexBytes) (*coretypes.ResultABCIQuery, error)); ok {
		return rf(ctx, path, data)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, bytes.HexBytes) *coretypes.ResultABCIQuery); ok {
		r0 = rf(ctx, path, data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultABCIQuery)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, bytes.HexBytes) error); ok {
		r1 = rf(ctx, path, data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RPCClient_ABCIQuery_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ABCIQuery'
type RPCClient_ABCIQuery_Call struct {
	*mock.Call
}

// ABCIQuery is a helper method to define mock.On call
//   - ctx context.Context
//   - path string
//   - data bytes.HexBytes
func (_e *RPCClient_Expecter) ABCIQuery(ctx interface{}, path interface{}, data interface{}) *RPCClient_ABCIQuery_Call {
	return &RPCClient_ABCIQuery_Call{Call: _e.mock.On("ABCIQuery", ctx, path, data)}
}

func (_c *RPCClient_ABCIQuery_Call) Run(run func(ctx context.Context, path string, data bytes.HexBytes)) *RPCClient_ABCIQuery_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(bytes.HexBytes))
	})
	return _c
}

func (_c *RPCClient_ABCIQuery_Call) Return(_a0 *coretypes.ResultABCIQuery, _a1 error) *RPCClient_ABCIQuery_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RPCClient_ABCIQuery_Call) RunAndReturn(run func(context.Context, string, bytes.HexBytes) (*coretypes.ResultABCIQuery, error)) *RPCClient_ABCIQuery_Call {
	_c.Call.Return(run)
	return _c
}

// ABCIQueryWithOptions provides a mock function with given fields: ctx, path, data, opts
func (_m *RPCClient) ABCIQueryWithOptions(ctx context.Context, path string, data bytes.HexBytes, opts client.ABCIQueryOptions) (*coretypes.ResultABCIQuery, error) {
	ret := _m.Called(ctx, path, data, opts)

	if len(ret) == 0 {
		panic("no return value specified for ABCIQueryWithOptions")
	}

	var r0 *coretypes.ResultABCIQuery
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, bytes.HexBytes, client.ABCIQueryOptions) (*coretypes.ResultABCIQuery, error)); ok {
		return rf(ctx, path, data, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, bytes.HexBytes, client.ABCIQueryOptions) *coretypes.ResultABCIQuery); ok {
		r0 = rf(ctx, path, data, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultABCIQuery)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, bytes.HexBytes, client.ABCIQueryOptions) error); ok {
		r1 = rf(ctx, path, data, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RPCClient_ABCIQueryWithOptions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ABCIQueryWithOptions'
type RPCClient_ABCIQueryWithOptions_Call struct {
	*mock.Call
}

// ABCIQueryWithOptions is a helper method to define mock.On call
//   - ctx context.Context
//   - path string
//   - data bytes.HexBytes
//   - opts client.ABCIQueryOptions
func (_e *RPCClient_Expecter) ABCIQueryWithOptions(ctx interface{}, path interface{}, data interface{}, opts interface{}) *RPCClient_ABCIQueryWithOptions_Call {
	return &RPCClient_ABCIQueryWithOptions_Call{Call: _e.mock.On("ABCIQueryWithOptions", ctx, path, data, opts)}
}

func (_c *RPCClient_ABCIQueryWithOptions_Call) Run(run func(ctx context.Context, path string, data bytes.HexBytes, opts client.ABCIQueryOptions)) *RPCClient_ABCIQueryWithOptions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(bytes.HexBytes), args[3].(client.ABCIQueryOptions))
	})
	return _c
}

func (_c *RPCClient_ABCIQueryWithOptions_Call) Return(_a0 *coretypes.ResultABCIQuery, _a1 error) *RPCClient_ABCIQueryWithOptions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RPCClient_ABCIQueryWithOptions_Call) RunAndReturn(run func(context.Context, string, bytes.HexBytes, client.ABCIQueryOptions) (*coretypes.ResultABCIQuery, error)) *RPCClient_ABCIQueryWithOptions_Call {
	_c.Call.Return(run)
	return _c
}

// Block provides a mock function with given fields: ctx, height
func (_m *RPCClient) Block(ctx context.Context, height *int64) (*coretypes.ResultBlock, error) {
	ret := _m.Called(ctx, height)

	if len(ret) == 0 {
		panic("no return value specified for Block")
	}

	var r0 *coretypes.ResultBlock
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *int64) (*coretypes.ResultBlock, error)); ok {
		return rf(ctx, height)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *int64) *coretypes.ResultBlock); ok {
		r0 = rf(ctx, height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultBlock)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *int64) error); ok {
		r1 = rf(ctx, height)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RPCClient_Block_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Block'
type RPCClient_Block_Call struct {
	*mock.Call
}

// Block is a helper method to define mock.On call
//   - ctx context.Context
//   - height *int64
func (_e *RPCClient_Expecter) Block(ctx interface{}, height interface{}) *RPCClient_Block_Call {
	return &RPCClient_Block_Call{Call: _e.mock.On("Block", ctx, height)}
}

func (_c *RPCClient_Block_Call) Run(run func(ctx context.Context, height *int64)) *RPCClient_Block_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*int64))
	})
	return _c
}

func (_c *RPCClient_Block_Call) Return(_a0 *coretypes.ResultBlock, _a1 error) *RPCClient_Block_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RPCClient_Block_Call) RunAndReturn(run func(context.Context, *int64) (*coretypes.ResultBlock, error)) *RPCClient_Block_Call {
	_c.Call.Return(run)
	return _c
}

// BlockByHash provides a mock function with given fields: ctx, hash
func (_m *RPCClient) BlockByHash(ctx context.Context, hash []byte) (*coretypes.ResultBlock, error) {
	ret := _m.Called(ctx, hash)

	if len(ret) == 0 {
		panic("no return value specified for BlockByHash")
	}

	var r0 *coretypes.ResultBlock
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []byte) (*coretypes.ResultBlock, error)); ok {
		return rf(ctx, hash)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []byte) *coretypes.ResultBlock); ok {
		r0 = rf(ctx, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultBlock)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []byte) error); ok {
		r1 = rf(ctx, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RPCClient_BlockByHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BlockByHash'
type RPCClient_BlockByHash_Call struct {
	*mock.Call
}

// BlockByHash is a helper method to define mock.On call
//   - ctx context.Context
//   - hash []byte
func (_e *RPCClient_Expecter) BlockByHash(ctx interface{}, hash interface{}) *RPCClient_BlockByHash_Call {
	return &RPCClient_BlockByHash_Call{Call: _e.mock.On("BlockByHash", ctx, hash)}
}

func (_c *RPCClient_BlockByHash_Call) Run(run func(ctx context.Context, hash []byte)) *RPCClient_BlockByHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]byte))
	})
	return _c
}

func (_c *RPCClient_BlockByHash_Call) Return(_a0 *coretypes.ResultBlock, _a1 error) *RPCClient_BlockByHash_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RPCClient_BlockByHash_Call) RunAndReturn(run func(context.Context, []byte) (*coretypes.ResultBlock, error)) *RPCClient_BlockByHash_Call {
	_c.Call.Return(run)
	return _c
}

// BlockResults provides a mock function with given fields: ctx, height
func (_m *RPCClient) BlockResults(ctx context.Context, height *int64) (*coretypes.ResultBlockResults, error) {
	ret := _m.Called(ctx, height)

	if len(ret) == 0 {
		panic("no return value specified for BlockResults")
	}

	var r0 *coretypes.ResultBlockResults
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *int64) (*coretypes.ResultBlockResults, error)); ok {
		return rf(ctx, height)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *int64) *coretypes.ResultBlockResults); ok {
		r0 = rf(ctx, height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultBlockResults)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *int64) error); ok {
		r1 = rf(ctx, height)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RPCClient_BlockResults_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BlockResults'
type RPCClient_BlockResults_Call struct {
	*mock.Call
}

// BlockResults is a helper method to define mock.On call
//   - ctx context.Context
//   - height *int64
func (_e *RPCClient_Expecter) BlockResults(ctx interface{}, height interface{}) *RPCClient_BlockResults_Call {
	return &RPCClient_BlockResults_Call{Call: _e.mock.On("BlockResults", ctx, height)}
}

func (_c *RPCClient_BlockResults_Call) Run(run func(ctx context.Context, height *int64)) *RPCClient_BlockResults_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*int64))
	})
	return _c
}

func (_c *RPCClient_BlockResults_Call) Return(_a0 *coretypes.ResultBlockResults, _a1 error) *RPCClient_BlockResults_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RPCClient_BlockResults_Call) RunAndReturn(run func(context.Context, *int64) (*coretypes.ResultBlockResults, error)) *RPCClient_BlockResults_Call {
	_c.Call.Return(run)
	return _c
}

// BlockSearch provides a mock function with given fields: ctx, query, page, perPage, orderBy
func (_m *RPCClient) BlockSearch(ctx context.Context, query string, page *int, perPage *int, orderBy string) (*coretypes.ResultBlockSearch, error) {
	ret := _m.Called(ctx, query, page, perPage, orderBy)

	if len(ret) == 0 {
		panic("no return value specified for BlockSearch")
	}

	var r0 *coretypes.ResultBlockSearch
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *int, *int, string) (*coretypes.ResultBlockSearch, error)); ok {
		return rf(ctx, query, page, perPage, orderBy)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *int, *int, string) *coretypes.ResultBlockSearch); ok {
		r0 = rf(ctx, query, page, perPage, orderBy)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultBlockSearch)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *int, *int, string) error); ok {
		r1 = rf(ctx, query, page, perPage, orderBy)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RPCClient_BlockSearch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BlockSearch'
type RPCClient_BlockSearch_Call struct {
	*mock.Call
}

// BlockSearch is a helper method to define mock.On call
//   - ctx context.Context
//   - query string
//   - page *int
//   - perPage *int
//   - orderBy string
func (_e *RPCClient_Expecter) BlockSearch(ctx interface{}, query interface{}, page interface{}, perPage interface{}, orderBy interface{}) *RPCClient_BlockSearch_Call {
	return &RPCClient_BlockSearch_Call{Call: _e.mock.On("BlockSearch", ctx, query, page, perPage, orderBy)}
}

func (_c *RPCClient_BlockSearch_Call) Run(run func(ctx context.Context, query string, page *int, perPage *int, orderBy string)) *RPCClient_BlockSearch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*int), args[3].(*int), args[4].(string))
	})
	return _c
}

func (_c *RPCClient_BlockSearch_Call) Return(_a0 *coretypes.ResultBlockSearch, _a1 error) *RPCClient_BlockSearch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RPCClient_BlockSearch_Call) RunAndReturn(run func(context.Context, string, *int, *int, string) (*coretypes.ResultBlockSearch, error)) *RPCClient_BlockSearch_Call {
	_c.Call.Return(run)
	return _c
}

// BlockchainInfo provides a mock function with given fields: ctx, minHeight, maxHeight
func (_m *RPCClient) BlockchainInfo(ctx context.Context, minHeight int64, maxHeight int64) (*coretypes.ResultBlockchainInfo, error) {
	ret := _m.Called(ctx, minHeight, maxHeight)

	if len(ret) == 0 {
		panic("no return value specified for BlockchainInfo")
	}

	var r0 *coretypes.ResultBlockchainInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int64, int64) (*coretypes.ResultBlockchainInfo, error)); ok {
		return rf(ctx, minHeight, maxHeight)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int64, int64) *coretypes.ResultBlockchainInfo); ok {
		r0 = rf(ctx, minHeight, maxHeight)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultBlockchainInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int64, int64) error); ok {
		r1 = rf(ctx, minHeight, maxHeight)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RPCClient_BlockchainInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BlockchainInfo'
type RPCClient_BlockchainInfo_Call struct {
	*mock.Call
}

// BlockchainInfo is a helper method to define mock.On call
//   - ctx context.Context
//   - minHeight int64
//   - maxHeight int64
func (_e *RPCClient_Expecter) BlockchainInfo(ctx interface{}, minHeight interface{}, maxHeight interface{}) *RPCClient_BlockchainInfo_Call {
	return &RPCClient_BlockchainInfo_Call{Call: _e.mock.On("BlockchainInfo", ctx, minHeight, maxHeight)}
}

func (_c *RPCClient_BlockchainInfo_Call) Run(run func(ctx context.Context, minHeight int64, maxHeight int64)) *RPCClient_BlockchainInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int64), args[2].(int64))
	})
	return _c
}

func (_c *RPCClient_BlockchainInfo_Call) Return(_a0 *coretypes.ResultBlockchainInfo, _a1 error) *RPCClient_BlockchainInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RPCClient_BlockchainInfo_Call) RunAndReturn(run func(context.Context, int64, int64) (*coretypes.ResultBlockchainInfo, error)) *RPCClient_BlockchainInfo_Call {
	_c.Call.Return(run)
	return _c
}

// BroadcastEvidence provides a mock function with given fields: _a0, _a1
func (_m *RPCClient) BroadcastEvidence(_a0 context.Context, _a1 types.Evidence) (*coretypes.ResultBroadcastEvidence, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for BroadcastEvidence")
	}

	var r0 *coretypes.ResultBroadcastEvidence
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.Evidence) (*coretypes.ResultBroadcastEvidence, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.Evidence) *coretypes.ResultBroadcastEvidence); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultBroadcastEvidence)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.Evidence) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RPCClient_BroadcastEvidence_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BroadcastEvidence'
type RPCClient_BroadcastEvidence_Call struct {
	*mock.Call
}

// BroadcastEvidence is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 types.Evidence
func (_e *RPCClient_Expecter) BroadcastEvidence(_a0 interface{}, _a1 interface{}) *RPCClient_BroadcastEvidence_Call {
	return &RPCClient_BroadcastEvidence_Call{Call: _e.mock.On("BroadcastEvidence", _a0, _a1)}
}

func (_c *RPCClient_BroadcastEvidence_Call) Run(run func(_a0 context.Context, _a1 types.Evidence)) *RPCClient_BroadcastEvidence_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.Evidence))
	})
	return _c
}

func (_c *RPCClient_BroadcastEvidence_Call) Return(_a0 *coretypes.ResultBroadcastEvidence, _a1 error) *RPCClient_BroadcastEvidence_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RPCClient_BroadcastEvidence_Call) RunAndReturn(run func(context.Context, types.Evidence) (*coretypes.ResultBroadcastEvidence, error)) *RPCClient_BroadcastEvidence_Call {
	_c.Call.Return(run)
	return _c
}

// BroadcastTxAsync provides a mock function with given fields: _a0, _a1
func (_m *RPCClient) BroadcastTxAsync(_a0 context.Context, _a1 types.Tx) (*coretypes.ResultBroadcastTx, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for BroadcastTxAsync")
	}

	var r0 *coretypes.ResultBroadcastTx
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.Tx) (*coretypes.ResultBroadcastTx, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.Tx) *coretypes.ResultBroadcastTx); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultBroadcastTx)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.Tx) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RPCClient_BroadcastTxAsync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BroadcastTxAsync'
type RPCClient_BroadcastTxAsync_Call struct {
	*mock.Call
}

// BroadcastTxAsync is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 types.Tx
func (_e *RPCClient_Expecter) BroadcastTxAsync(_a0 interface{}, _a1 interface{}) *RPCClient_BroadcastTxAsync_Call {
	return &RPCClient_BroadcastTxAsync_Call{Call: _e.mock.On("BroadcastTxAsync", _a0, _a1)}
}

func (_c *RPCClient_BroadcastTxAsync_Call) Run(run func(_a0 context.Context, _a1 types.Tx)) *RPCClient_BroadcastTxAsync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.Tx))
	})
	return _c
}

func (_c *RPCClient_BroadcastTxAsync_Call) Return(_a0 *coretypes.ResultBroadcastTx, _a1 error) *RPCClient_BroadcastTxAsync_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RPCClient_BroadcastTxAsync_Call) RunAndReturn(run func(context.Context, types.Tx) (*coretypes.ResultBroadcastTx, error)) *RPCClient_BroadcastTxAsync_Call {
	_c.Call.Return(run)
	return _c
}

// BroadcastTxCommit provides a mock function with given fields: _a0, _a1
func (_m *RPCClient) BroadcastTxCommit(_a0 context.Context, _a1 types.Tx) (*coretypes.ResultBroadcastTxCommit, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for BroadcastTxCommit")
	}

	var r0 *coretypes.ResultBroadcastTxCommit
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.Tx) (*coretypes.ResultBroadcastTxCommit, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.Tx) *coretypes.ResultBroadcastTxCommit); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultBroadcastTxCommit)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.Tx) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RPCClient_BroadcastTxCommit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BroadcastTxCommit'
type RPCClient_BroadcastTxCommit_Call struct {
	*mock.Call
}

// BroadcastTxCommit is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 types.Tx
func (_e *RPCClient_Expecter) BroadcastTxCommit(_a0 interface{}, _a1 interface{}) *RPCClient_BroadcastTxCommit_Call {
	return &RPCClient_BroadcastTxCommit_Call{Call: _e.mock.On("BroadcastTxCommit", _a0, _a1)}
}

func (_c *RPCClient_BroadcastTxCommit_Call) Run(run func(_a0 context.Context, _a1 types.Tx)) *RPCClient_BroadcastTxCommit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.Tx))
	})
	return _c
}

func (_c *RPCClient_BroadcastTxCommit_Call) Return(_a0 *coretypes.ResultBroadcastTxCommit, _a1 error) *RPCClient_BroadcastTxCommit_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RPCClient_BroadcastTxCommit_Call) RunAndReturn(run func(context.Context, types.Tx) (*coretypes.ResultBroadcastTxCommit, error)) *RPCClient_BroadcastTxCommit_Call {
	_c.Call.Return(run)
	return _c
}

// BroadcastTxSync provides a mock function with given fields: _a0, _a1
func (_m *RPCClient) BroadcastTxSync(_a0 context.Context, _a1 types.Tx) (*coretypes.ResultBroadcastTx, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for BroadcastTxSync")
	}

	var r0 *coretypes.ResultBroadcastTx
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.Tx) (*coretypes.ResultBroadcastTx, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.Tx) *coretypes.ResultBroadcastTx); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultBroadcastTx)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.Tx) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RPCClient_BroadcastTxSync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BroadcastTxSync'
type RPCClient_BroadcastTxSync_Call struct {
	*mock.Call
}

// BroadcastTxSync is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 types.Tx
func (_e *RPCClient_Expecter) BroadcastTxSync(_a0 interface{}, _a1 interface{}) *RPCClient_BroadcastTxSync_Call {
	return &RPCClient_BroadcastTxSync_Call{Call: _e.mock.On("BroadcastTxSync", _a0, _a1)}
}

func (_c *RPCClient_BroadcastTxSync_Call) Run(run func(_a0 context.Context, _a1 types.Tx)) *RPCClient_BroadcastTxSync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.Tx))
	})
	return _c
}

func (_c *RPCClient_BroadcastTxSync_Call) Return(_a0 *coretypes.ResultBroadcastTx, _a1 error) *RPCClient_BroadcastTxSync_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RPCClient_BroadcastTxSync_Call) RunAndReturn(run func(context.Context, types.Tx) (*coretypes.ResultBroadcastTx, error)) *RPCClient_BroadcastTxSync_Call {
	_c.Call.Return(run)
	return _c
}

// CheckTx provides a mock function with given fields: _a0, _a1
func (_m *RPCClient) CheckTx(_a0 context.Context, _a1 types.Tx) (*coretypes.ResultCheckTx, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for CheckTx")
	}

	var r0 *coretypes.ResultCheckTx
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, types.Tx) (*coretypes.ResultCheckTx, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, types.Tx) *coretypes.ResultCheckTx); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultCheckTx)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, types.Tx) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RPCClient_CheckTx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CheckTx'
type RPCClient_CheckTx_Call struct {
	*mock.Call
}

// CheckTx is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 types.Tx
func (_e *RPCClient_Expecter) CheckTx(_a0 interface{}, _a1 interface{}) *RPCClient_CheckTx_Call {
	return &RPCClient_CheckTx_Call{Call: _e.mock.On("CheckTx", _a0, _a1)}
}

func (_c *RPCClient_CheckTx_Call) Run(run func(_a0 context.Context, _a1 types.Tx)) *RPCClient_CheckTx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(types.Tx))
	})
	return _c
}

func (_c *RPCClient_CheckTx_Call) Return(_a0 *coretypes.ResultCheckTx, _a1 error) *RPCClient_CheckTx_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RPCClient_CheckTx_Call) RunAndReturn(run func(context.Context, types.Tx) (*coretypes.ResultCheckTx, error)) *RPCClient_CheckTx_Call {
	_c.Call.Return(run)
	return _c
}

// Commit provides a mock function with given fields: ctx, height
func (_m *RPCClient) Commit(ctx context.Context, height *int64) (*coretypes.ResultCommit, error) {
	ret := _m.Called(ctx, height)

	if len(ret) == 0 {
		panic("no return value specified for Commit")
	}

	var r0 *coretypes.ResultCommit
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *int64) (*coretypes.ResultCommit, error)); ok {
		return rf(ctx, height)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *int64) *coretypes.ResultCommit); ok {
		r0 = rf(ctx, height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultCommit)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *int64) error); ok {
		r1 = rf(ctx, height)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RPCClient_Commit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Commit'
type RPCClient_Commit_Call struct {
	*mock.Call
}

// Commit is a helper method to define mock.On call
//   - ctx context.Context
//   - height *int64
func (_e *RPCClient_Expecter) Commit(ctx interface{}, height interface{}) *RPCClient_Commit_Call {
	return &RPCClient_Commit_Call{Call: _e.mock.On("Commit", ctx, height)}
}

func (_c *RPCClient_Commit_Call) Run(run func(ctx context.Context, height *int64)) *RPCClient_Commit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*int64))
	})
	return _c
}

func (_c *RPCClient_Commit_Call) Return(_a0 *coretypes.ResultCommit, _a1 error) *RPCClient_Commit_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RPCClient_Commit_Call) RunAndReturn(run func(context.Context, *int64) (*coretypes.ResultCommit, error)) *RPCClient_Commit_Call {
	_c.Call.Return(run)
	return _c
}

// ConsensusParams provides a mock function with given fields: ctx, height
func (_m *RPCClient) ConsensusParams(ctx context.Context, height *int64) (*coretypes.ResultConsensusParams, error) {
	ret := _m.Called(ctx, height)

	if len(ret) == 0 {
		panic("no return value specified for ConsensusParams")
	}

	var r0 *coretypes.ResultConsensusParams
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *int64) (*coretypes.ResultConsensusParams, error)); ok {
		return rf(ctx, height)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *int64) *coretypes.ResultConsensusParams); ok {
		r0 = rf(ctx, height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultConsensusParams)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *int64) error); ok {
		r1 = rf(ctx, height)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RPCClient_ConsensusParams_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConsensusParams'
type RPCClient_ConsensusParams_Call struct {
	*mock.Call
}

// ConsensusParams is a helper method to define mock.On call
//   - ctx context.Context
//   - height *int64
func (_e *RPCClient_Expecter) ConsensusParams(ctx interface{}, height interface{}) *RPCClient_ConsensusParams_Call {
	return &RPCClient_ConsensusParams_Call{Call: _e.mock.On("ConsensusParams", ctx, height)}
}

func (_c *RPCClient_ConsensusParams_Call) Run(run func(ctx context.Context, height *int64)) *RPCClient_ConsensusParams_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*int64))
	})
	return _c
}

func (_c *RPCClient_ConsensusParams_Call) Return(_a0 *coretypes.ResultConsensusParams, _a1 error) *RPCClient_ConsensusParams_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RPCClient_ConsensusParams_Call) RunAndReturn(run func(context.Context, *int64) (*coretypes.ResultConsensusParams, error)) *RPCClient_ConsensusParams_Call {
	_c.Call.Return(run)
	return _c
}

// ConsensusState provides a mock function with given fields: _a0
func (_m *RPCClient) ConsensusState(_a0 context.Context) (*coretypes.ResultConsensusState, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for ConsensusState")
	}

	var r0 *coretypes.ResultConsensusState
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*coretypes.ResultConsensusState, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *coretypes.ResultConsensusState); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultConsensusState)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RPCClient_ConsensusState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConsensusState'
type RPCClient_ConsensusState_Call struct {
	*mock.Call
}

// ConsensusState is a helper method to define mock.On call
//   - _a0 context.Context
func (_e *RPCClient_Expecter) ConsensusState(_a0 interface{}) *RPCClient_ConsensusState_Call {
	return &RPCClient_ConsensusState_Call{Call: _e.mock.On("ConsensusState", _a0)}
}

func (_c *RPCClient_ConsensusState_Call) Run(run func(_a0 context.Context)) *RPCClient_ConsensusState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *RPCClient_ConsensusState_Call) Return(_a0 *coretypes.ResultConsensusState, _a1 error) *RPCClient_ConsensusState_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RPCClient_ConsensusState_Call) RunAndReturn(run func(context.Context) (*coretypes.ResultConsensusState, error)) *RPCClient_ConsensusState_Call {
	_c.Call.Return(run)
	return _c
}

// DumpConsensusState provides a mock function with given fields: _a0
func (_m *RPCClient) DumpConsensusState(_a0 context.Context) (*coretypes.ResultDumpConsensusState, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for DumpConsensusState")
	}

	var r0 *coretypes.ResultDumpConsensusState
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*coretypes.ResultDumpConsensusState, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *coretypes.ResultDumpConsensusState); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultDumpConsensusState)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RPCClient_DumpConsensusState_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DumpConsensusState'
type RPCClient_DumpConsensusState_Call struct {
	*mock.Call
}

// DumpConsensusState is a helper method to define mock.On call
//   - _a0 context.Context
func (_e *RPCClient_Expecter) DumpConsensusState(_a0 interface{}) *RPCClient_DumpConsensusState_Call {
	return &RPCClient_DumpConsensusState_Call{Call: _e.mock.On("DumpConsensusState", _a0)}
}

func (_c *RPCClient_DumpConsensusState_Call) Run(run func(_a0 context.Context)) *RPCClient_DumpConsensusState_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *RPCClient_DumpConsensusState_Call) Return(_a0 *coretypes.ResultDumpConsensusState, _a1 error) *RPCClient_DumpConsensusState_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RPCClient_DumpConsensusState_Call) RunAndReturn(run func(context.Context) (*coretypes.ResultDumpConsensusState, error)) *RPCClient_DumpConsensusState_Call {
	_c.Call.Return(run)
	return _c
}

// Genesis provides a mock function with given fields: _a0
func (_m *RPCClient) Genesis(_a0 context.Context) (*coretypes.ResultGenesis, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for Genesis")
	}

	var r0 *coretypes.ResultGenesis
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*coretypes.ResultGenesis, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *coretypes.ResultGenesis); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultGenesis)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RPCClient_Genesis_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Genesis'
type RPCClient_Genesis_Call struct {
	*mock.Call
}

// Genesis is a helper method to define mock.On call
//   - _a0 context.Context
func (_e *RPCClient_Expecter) Genesis(_a0 interface{}) *RPCClient_Genesis_Call {
	return &RPCClient_Genesis_Call{Call: _e.mock.On("Genesis", _a0)}
}

func (_c *RPCClient_Genesis_Call) Run(run func(_a0 context.Context)) *RPCClient_Genesis_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *RPCClient_Genesis_Call) Return(_a0 *coretypes.ResultGenesis, _a1 error) *RPCClient_Genesis_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RPCClient_Genesis_Call) RunAndReturn(run func(context.Context) (*coretypes.ResultGenesis, error)) *RPCClient_Genesis_Call {
	_c.Call.Return(run)
	return _c
}

// GenesisChunked provides a mock function with given fields: _a0, _a1
func (_m *RPCClient) GenesisChunked(_a0 context.Context, _a1 uint) (*coretypes.ResultGenesisChunk, error) {
	ret := _m.Called(_a0, _a1)

	if len(ret) == 0 {
		panic("no return value specified for GenesisChunked")
	}

	var r0 *coretypes.ResultGenesisChunk
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, uint) (*coretypes.ResultGenesisChunk, error)); ok {
		return rf(_a0, _a1)
	}
	if rf, ok := ret.Get(0).(func(context.Context, uint) *coretypes.ResultGenesisChunk); ok {
		r0 = rf(_a0, _a1)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultGenesisChunk)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, uint) error); ok {
		r1 = rf(_a0, _a1)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RPCClient_GenesisChunked_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GenesisChunked'
type RPCClient_GenesisChunked_Call struct {
	*mock.Call
}

// GenesisChunked is a helper method to define mock.On call
//   - _a0 context.Context
//   - _a1 uint
func (_e *RPCClient_Expecter) GenesisChunked(_a0 interface{}, _a1 interface{}) *RPCClient_GenesisChunked_Call {
	return &RPCClient_GenesisChunked_Call{Call: _e.mock.On("GenesisChunked", _a0, _a1)}
}

func (_c *RPCClient_GenesisChunked_Call) Run(run func(_a0 context.Context, _a1 uint)) *RPCClient_GenesisChunked_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(uint))
	})
	return _c
}

func (_c *RPCClient_GenesisChunked_Call) Return(_a0 *coretypes.ResultGenesisChunk, _a1 error) *RPCClient_GenesisChunked_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RPCClient_GenesisChunked_Call) RunAndReturn(run func(context.Context, uint) (*coretypes.ResultGenesisChunk, error)) *RPCClient_GenesisChunked_Call {
	_c.Call.Return(run)
	return _c
}

// Header provides a mock function with given fields: ctx, height
func (_m *RPCClient) Header(ctx context.Context, height *int64) (*coretypes.ResultHeader, error) {
	ret := _m.Called(ctx, height)

	if len(ret) == 0 {
		panic("no return value specified for Header")
	}

	var r0 *coretypes.ResultHeader
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *int64) (*coretypes.ResultHeader, error)); ok {
		return rf(ctx, height)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *int64) *coretypes.ResultHeader); ok {
		r0 = rf(ctx, height)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultHeader)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *int64) error); ok {
		r1 = rf(ctx, height)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RPCClient_Header_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Header'
type RPCClient_Header_Call struct {
	*mock.Call
}

// Header is a helper method to define mock.On call
//   - ctx context.Context
//   - height *int64
func (_e *RPCClient_Expecter) Header(ctx interface{}, height interface{}) *RPCClient_Header_Call {
	return &RPCClient_Header_Call{Call: _e.mock.On("Header", ctx, height)}
}

func (_c *RPCClient_Header_Call) Run(run func(ctx context.Context, height *int64)) *RPCClient_Header_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*int64))
	})
	return _c
}

func (_c *RPCClient_Header_Call) Return(_a0 *coretypes.ResultHeader, _a1 error) *RPCClient_Header_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RPCClient_Header_Call) RunAndReturn(run func(context.Context, *int64) (*coretypes.ResultHeader, error)) *RPCClient_Header_Call {
	_c.Call.Return(run)
	return _c
}

// HeaderByHash provides a mock function with given fields: ctx, hash
func (_m *RPCClient) HeaderByHash(ctx context.Context, hash bytes.HexBytes) (*coretypes.ResultHeader, error) {
	ret := _m.Called(ctx, hash)

	if len(ret) == 0 {
		panic("no return value specified for HeaderByHash")
	}

	var r0 *coretypes.ResultHeader
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, bytes.HexBytes) (*coretypes.ResultHeader, error)); ok {
		return rf(ctx, hash)
	}
	if rf, ok := ret.Get(0).(func(context.Context, bytes.HexBytes) *coretypes.ResultHeader); ok {
		r0 = rf(ctx, hash)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultHeader)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, bytes.HexBytes) error); ok {
		r1 = rf(ctx, hash)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RPCClient_HeaderByHash_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HeaderByHash'
type RPCClient_HeaderByHash_Call struct {
	*mock.Call
}

// HeaderByHash is a helper method to define mock.On call
//   - ctx context.Context
//   - hash bytes.HexBytes
func (_e *RPCClient_Expecter) HeaderByHash(ctx interface{}, hash interface{}) *RPCClient_HeaderByHash_Call {
	return &RPCClient_HeaderByHash_Call{Call: _e.mock.On("HeaderByHash", ctx, hash)}
}

func (_c *RPCClient_HeaderByHash_Call) Run(run func(ctx context.Context, hash bytes.HexBytes)) *RPCClient_HeaderByHash_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(bytes.HexBytes))
	})
	return _c
}

func (_c *RPCClient_HeaderByHash_Call) Return(_a0 *coretypes.ResultHeader, _a1 error) *RPCClient_HeaderByHash_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RPCClient_HeaderByHash_Call) RunAndReturn(run func(context.Context, bytes.HexBytes) (*coretypes.ResultHeader, error)) *RPCClient_HeaderByHash_Call {
	_c.Call.Return(run)
	return _c
}

// Health provides a mock function with given fields: _a0
func (_m *RPCClient) Health(_a0 context.Context) (*coretypes.ResultHealth, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for Health")
	}

	var r0 *coretypes.ResultHealth
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*coretypes.ResultHealth, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *coretypes.ResultHealth); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultHealth)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RPCClient_Health_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Health'
type RPCClient_Health_Call struct {
	*mock.Call
}

// Health is a helper method to define mock.On call
//   - _a0 context.Context
func (_e *RPCClient_Expecter) Health(_a0 interface{}) *RPCClient_Health_Call {
	return &RPCClient_Health_Call{Call: _e.mock.On("Health", _a0)}
}

func (_c *RPCClient_Health_Call) Run(run func(_a0 context.Context)) *RPCClient_Health_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *RPCClient_Health_Call) Return(_a0 *coretypes.ResultHealth, _a1 error) *RPCClient_Health_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RPCClient_Health_Call) RunAndReturn(run func(context.Context) (*coretypes.ResultHealth, error)) *RPCClient_Health_Call {
	_c.Call.Return(run)
	return _c
}

// IsRunning provides a mock function with given fields:
func (_m *RPCClient) IsRunning() bool {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for IsRunning")
	}

	var r0 bool
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// RPCClient_IsRunning_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsRunning'
type RPCClient_IsRunning_Call struct {
	*mock.Call
}

// IsRunning is a helper method to define mock.On call
func (_e *RPCClient_Expecter) IsRunning() *RPCClient_IsRunning_Call {
	return &RPCClient_IsRunning_Call{Call: _e.mock.On("IsRunning")}
}

func (_c *RPCClient_IsRunning_Call) Run(run func()) *RPCClient_IsRunning_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RPCClient_IsRunning_Call) Return(_a0 bool) *RPCClient_IsRunning_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RPCClient_IsRunning_Call) RunAndReturn(run func() bool) *RPCClient_IsRunning_Call {
	_c.Call.Return(run)
	return _c
}

// NetInfo provides a mock function with given fields: _a0
func (_m *RPCClient) NetInfo(_a0 context.Context) (*coretypes.ResultNetInfo, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for NetInfo")
	}

	var r0 *coretypes.ResultNetInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*coretypes.ResultNetInfo, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *coretypes.ResultNetInfo); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultNetInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RPCClient_NetInfo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NetInfo'
type RPCClient_NetInfo_Call struct {
	*mock.Call
}

// NetInfo is a helper method to define mock.On call
//   - _a0 context.Context
func (_e *RPCClient_Expecter) NetInfo(_a0 interface{}) *RPCClient_NetInfo_Call {
	return &RPCClient_NetInfo_Call{Call: _e.mock.On("NetInfo", _a0)}
}

func (_c *RPCClient_NetInfo_Call) Run(run func(_a0 context.Context)) *RPCClient_NetInfo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *RPCClient_NetInfo_Call) Return(_a0 *coretypes.ResultNetInfo, _a1 error) *RPCClient_NetInfo_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RPCClient_NetInfo_Call) RunAndReturn(run func(context.Context) (*coretypes.ResultNetInfo, error)) *RPCClient_NetInfo_Call {
	_c.Call.Return(run)
	return _c
}

// NumUnconfirmedTxs provides a mock function with given fields: _a0
func (_m *RPCClient) NumUnconfirmedTxs(_a0 context.Context) (*coretypes.ResultUnconfirmedTxs, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for NumUnconfirmedTxs")
	}

	var r0 *coretypes.ResultUnconfirmedTxs
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*coretypes.ResultUnconfirmedTxs, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *coretypes.ResultUnconfirmedTxs); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultUnconfirmedTxs)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RPCClient_NumUnconfirmedTxs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'NumUnconfirmedTxs'
type RPCClient_NumUnconfirmedTxs_Call struct {
	*mock.Call
}

// NumUnconfirmedTxs is a helper method to define mock.On call
//   - _a0 context.Context
func (_e *RPCClient_Expecter) NumUnconfirmedTxs(_a0 interface{}) *RPCClient_NumUnconfirmedTxs_Call {
	return &RPCClient_NumUnconfirmedTxs_Call{Call: _e.mock.On("NumUnconfirmedTxs", _a0)}
}

func (_c *RPCClient_NumUnconfirmedTxs_Call) Run(run func(_a0 context.Context)) *RPCClient_NumUnconfirmedTxs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *RPCClient_NumUnconfirmedTxs_Call) Return(_a0 *coretypes.ResultUnconfirmedTxs, _a1 error) *RPCClient_NumUnconfirmedTxs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RPCClient_NumUnconfirmedTxs_Call) RunAndReturn(run func(context.Context) (*coretypes.ResultUnconfirmedTxs, error)) *RPCClient_NumUnconfirmedTxs_Call {
	_c.Call.Return(run)
	return _c
}

// OnReset provides a mock function with given fields:
func (_m *RPCClient) OnReset() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for OnReset")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RPCClient_OnReset_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnReset'
type RPCClient_OnReset_Call struct {
	*mock.Call
}

// OnReset is a helper method to define mock.On call
func (_e *RPCClient_Expecter) OnReset() *RPCClient_OnReset_Call {
	return &RPCClient_OnReset_Call{Call: _e.mock.On("OnReset")}
}

func (_c *RPCClient_OnReset_Call) Run(run func()) *RPCClient_OnReset_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RPCClient_OnReset_Call) Return(_a0 error) *RPCClient_OnReset_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RPCClient_OnReset_Call) RunAndReturn(run func() error) *RPCClient_OnReset_Call {
	_c.Call.Return(run)
	return _c
}

// OnStart provides a mock function with given fields:
func (_m *RPCClient) OnStart() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for OnStart")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RPCClient_OnStart_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnStart'
type RPCClient_OnStart_Call struct {
	*mock.Call
}

// OnStart is a helper method to define mock.On call
func (_e *RPCClient_Expecter) OnStart() *RPCClient_OnStart_Call {
	return &RPCClient_OnStart_Call{Call: _e.mock.On("OnStart")}
}

func (_c *RPCClient_OnStart_Call) Run(run func()) *RPCClient_OnStart_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RPCClient_OnStart_Call) Return(_a0 error) *RPCClient_OnStart_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RPCClient_OnStart_Call) RunAndReturn(run func() error) *RPCClient_OnStart_Call {
	_c.Call.Return(run)
	return _c
}

// OnStop provides a mock function with given fields:
func (_m *RPCClient) OnStop() {
	_m.Called()
}

// RPCClient_OnStop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'OnStop'
type RPCClient_OnStop_Call struct {
	*mock.Call
}

// OnStop is a helper method to define mock.On call
func (_e *RPCClient_Expecter) OnStop() *RPCClient_OnStop_Call {
	return &RPCClient_OnStop_Call{Call: _e.mock.On("OnStop")}
}

func (_c *RPCClient_OnStop_Call) Run(run func()) *RPCClient_OnStop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RPCClient_OnStop_Call) Return() *RPCClient_OnStop_Call {
	_c.Call.Return()
	return _c
}

func (_c *RPCClient_OnStop_Call) RunAndReturn(run func()) *RPCClient_OnStop_Call {
	_c.Call.Return(run)
	return _c
}

// Quit provides a mock function with given fields:
func (_m *RPCClient) Quit() <-chan struct{} {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Quit")
	}

	var r0 <-chan struct{}
	if rf, ok := ret.Get(0).(func() <-chan struct{}); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan struct{})
		}
	}

	return r0
}

// RPCClient_Quit_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Quit'
type RPCClient_Quit_Call struct {
	*mock.Call
}

// Quit is a helper method to define mock.On call
func (_e *RPCClient_Expecter) Quit() *RPCClient_Quit_Call {
	return &RPCClient_Quit_Call{Call: _e.mock.On("Quit")}
}

func (_c *RPCClient_Quit_Call) Run(run func()) *RPCClient_Quit_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RPCClient_Quit_Call) Return(_a0 <-chan struct{}) *RPCClient_Quit_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RPCClient_Quit_Call) RunAndReturn(run func() <-chan struct{}) *RPCClient_Quit_Call {
	_c.Call.Return(run)
	return _c
}

// Reset provides a mock function with given fields:
func (_m *RPCClient) Reset() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Reset")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RPCClient_Reset_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Reset'
type RPCClient_Reset_Call struct {
	*mock.Call
}

// Reset is a helper method to define mock.On call
func (_e *RPCClient_Expecter) Reset() *RPCClient_Reset_Call {
	return &RPCClient_Reset_Call{Call: _e.mock.On("Reset")}
}

func (_c *RPCClient_Reset_Call) Run(run func()) *RPCClient_Reset_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RPCClient_Reset_Call) Return(_a0 error) *RPCClient_Reset_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RPCClient_Reset_Call) RunAndReturn(run func() error) *RPCClient_Reset_Call {
	_c.Call.Return(run)
	return _c
}

// SetLogger provides a mock function with given fields: _a0
func (_m *RPCClient) SetLogger(_a0 log.Logger) {
	_m.Called(_a0)
}

// RPCClient_SetLogger_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetLogger'
type RPCClient_SetLogger_Call struct {
	*mock.Call
}

// SetLogger is a helper method to define mock.On call
//   - _a0 log.Logger
func (_e *RPCClient_Expecter) SetLogger(_a0 interface{}) *RPCClient_SetLogger_Call {
	return &RPCClient_SetLogger_Call{Call: _e.mock.On("SetLogger", _a0)}
}

func (_c *RPCClient_SetLogger_Call) Run(run func(_a0 log.Logger)) *RPCClient_SetLogger_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(log.Logger))
	})
	return _c
}

func (_c *RPCClient_SetLogger_Call) Return() *RPCClient_SetLogger_Call {
	_c.Call.Return()
	return _c
}

func (_c *RPCClient_SetLogger_Call) RunAndReturn(run func(log.Logger)) *RPCClient_SetLogger_Call {
	_c.Call.Return(run)
	return _c
}

// Start provides a mock function with given fields:
func (_m *RPCClient) Start() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Start")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RPCClient_Start_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Start'
type RPCClient_Start_Call struct {
	*mock.Call
}

// Start is a helper method to define mock.On call
func (_e *RPCClient_Expecter) Start() *RPCClient_Start_Call {
	return &RPCClient_Start_Call{Call: _e.mock.On("Start")}
}

func (_c *RPCClient_Start_Call) Run(run func()) *RPCClient_Start_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RPCClient_Start_Call) Return(_a0 error) *RPCClient_Start_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RPCClient_Start_Call) RunAndReturn(run func() error) *RPCClient_Start_Call {
	_c.Call.Return(run)
	return _c
}

// Status provides a mock function with given fields: _a0
func (_m *RPCClient) Status(_a0 context.Context) (*coretypes.ResultStatus, error) {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for Status")
	}

	var r0 *coretypes.ResultStatus
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*coretypes.ResultStatus, error)); ok {
		return rf(_a0)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *coretypes.ResultStatus); ok {
		r0 = rf(_a0)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultStatus)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(_a0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RPCClient_Status_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Status'
type RPCClient_Status_Call struct {
	*mock.Call
}

// Status is a helper method to define mock.On call
//   - _a0 context.Context
func (_e *RPCClient_Expecter) Status(_a0 interface{}) *RPCClient_Status_Call {
	return &RPCClient_Status_Call{Call: _e.mock.On("Status", _a0)}
}

func (_c *RPCClient_Status_Call) Run(run func(_a0 context.Context)) *RPCClient_Status_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *RPCClient_Status_Call) Return(_a0 *coretypes.ResultStatus, _a1 error) *RPCClient_Status_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RPCClient_Status_Call) RunAndReturn(run func(context.Context) (*coretypes.ResultStatus, error)) *RPCClient_Status_Call {
	_c.Call.Return(run)
	return _c
}

// Stop provides a mock function with given fields:
func (_m *RPCClient) Stop() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Stop")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RPCClient_Stop_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Stop'
type RPCClient_Stop_Call struct {
	*mock.Call
}

// Stop is a helper method to define mock.On call
func (_e *RPCClient_Expecter) Stop() *RPCClient_Stop_Call {
	return &RPCClient_Stop_Call{Call: _e.mock.On("Stop")}
}

func (_c *RPCClient_Stop_Call) Run(run func()) *RPCClient_Stop_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RPCClient_Stop_Call) Return(_a0 error) *RPCClient_Stop_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RPCClient_Stop_Call) RunAndReturn(run func() error) *RPCClient_Stop_Call {
	_c.Call.Return(run)
	return _c
}

// String provides a mock function with given fields:
func (_m *RPCClient) String() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for String")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// RPCClient_String_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'String'
type RPCClient_String_Call struct {
	*mock.Call
}

// String is a helper method to define mock.On call
func (_e *RPCClient_Expecter) String() *RPCClient_String_Call {
	return &RPCClient_String_Call{Call: _e.mock.On("String")}
}

func (_c *RPCClient_String_Call) Run(run func()) *RPCClient_String_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *RPCClient_String_Call) Return(_a0 string) *RPCClient_String_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RPCClient_String_Call) RunAndReturn(run func() string) *RPCClient_String_Call {
	_c.Call.Return(run)
	return _c
}

// Subscribe provides a mock function with given fields: ctx, subscriber, query, outCapacity
func (_m *RPCClient) Subscribe(ctx context.Context, subscriber string, query string, outCapacity ...int) (<-chan coretypes.ResultEvent, error) {
	_va := make([]interface{}, len(outCapacity))
	for _i := range outCapacity {
		_va[_i] = outCapacity[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, subscriber, query)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Subscribe")
	}

	var r0 <-chan coretypes.ResultEvent
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ...int) (<-chan coretypes.ResultEvent, error)); ok {
		return rf(ctx, subscriber, query, outCapacity...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ...int) <-chan coretypes.ResultEvent); ok {
		r0 = rf(ctx, subscriber, query, outCapacity...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan coretypes.ResultEvent)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, ...int) error); ok {
		r1 = rf(ctx, subscriber, query, outCapacity...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RPCClient_Subscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Subscribe'
type RPCClient_Subscribe_Call struct {
	*mock.Call
}

// Subscribe is a helper method to define mock.On call
//   - ctx context.Context
//   - subscriber string
//   - query string
//   - outCapacity ...int
func (_e *RPCClient_Expecter) Subscribe(ctx interface{}, subscriber interface{}, query interface{}, outCapacity ...interface{}) *RPCClient_Subscribe_Call {
	return &RPCClient_Subscribe_Call{Call: _e.mock.On("Subscribe",
		append([]interface{}{ctx, subscriber, query}, outCapacity...)...)}
}

func (_c *RPCClient_Subscribe_Call) Run(run func(ctx context.Context, subscriber string, query string, outCapacity ...int)) *RPCClient_Subscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]int, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(int)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(string), variadicArgs...)
	})
	return _c
}

func (_c *RPCClient_Subscribe_Call) Return(out <-chan coretypes.ResultEvent, err error) *RPCClient_Subscribe_Call {
	_c.Call.Return(out, err)
	return _c
}

func (_c *RPCClient_Subscribe_Call) RunAndReturn(run func(context.Context, string, string, ...int) (<-chan coretypes.ResultEvent, error)) *RPCClient_Subscribe_Call {
	_c.Call.Return(run)
	return _c
}

// Tx provides a mock function with given fields: ctx, hash, prove
func (_m *RPCClient) Tx(ctx context.Context, hash []byte, prove bool) (*coretypes.ResultTx, error) {
	ret := _m.Called(ctx, hash, prove)

	if len(ret) == 0 {
		panic("no return value specified for Tx")
	}

	var r0 *coretypes.ResultTx
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []byte, bool) (*coretypes.ResultTx, error)); ok {
		return rf(ctx, hash, prove)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []byte, bool) *coretypes.ResultTx); ok {
		r0 = rf(ctx, hash, prove)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultTx)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []byte, bool) error); ok {
		r1 = rf(ctx, hash, prove)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RPCClient_Tx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Tx'
type RPCClient_Tx_Call struct {
	*mock.Call
}

// Tx is a helper method to define mock.On call
//   - ctx context.Context
//   - hash []byte
//   - prove bool
func (_e *RPCClient_Expecter) Tx(ctx interface{}, hash interface{}, prove interface{}) *RPCClient_Tx_Call {
	return &RPCClient_Tx_Call{Call: _e.mock.On("Tx", ctx, hash, prove)}
}

func (_c *RPCClient_Tx_Call) Run(run func(ctx context.Context, hash []byte, prove bool)) *RPCClient_Tx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]byte), args[2].(bool))
	})
	return _c
}

func (_c *RPCClient_Tx_Call) Return(_a0 *coretypes.ResultTx, _a1 error) *RPCClient_Tx_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RPCClient_Tx_Call) RunAndReturn(run func(context.Context, []byte, bool) (*coretypes.ResultTx, error)) *RPCClient_Tx_Call {
	_c.Call.Return(run)
	return _c
}

// TxSearch provides a mock function with given fields: ctx, query, prove, page, perPage, orderBy
func (_m *RPCClient) TxSearch(ctx context.Context, query string, prove bool, page *int, perPage *int, orderBy string) (*coretypes.ResultTxSearch, error) {
	ret := _m.Called(ctx, query, prove, page, perPage, orderBy)

	if len(ret) == 0 {
		panic("no return value specified for TxSearch")
	}

	var r0 *coretypes.ResultTxSearch
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, bool, *int, *int, string) (*coretypes.ResultTxSearch, error)); ok {
		return rf(ctx, query, prove, page, perPage, orderBy)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, bool, *int, *int, string) *coretypes.ResultTxSearch); ok {
		r0 = rf(ctx, query, prove, page, perPage, orderBy)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultTxSearch)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, bool, *int, *int, string) error); ok {
		r1 = rf(ctx, query, prove, page, perPage, orderBy)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RPCClient_TxSearch_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'TxSearch'
type RPCClient_TxSearch_Call struct {
	*mock.Call
}

// TxSearch is a helper method to define mock.On call
//   - ctx context.Context
//   - query string
//   - prove bool
//   - page *int
//   - perPage *int
//   - orderBy string
func (_e *RPCClient_Expecter) TxSearch(ctx interface{}, query interface{}, prove interface{}, page interface{}, perPage interface{}, orderBy interface{}) *RPCClient_TxSearch_Call {
	return &RPCClient_TxSearch_Call{Call: _e.mock.On("TxSearch", ctx, query, prove, page, perPage, orderBy)}
}

func (_c *RPCClient_TxSearch_Call) Run(run func(ctx context.Context, query string, prove bool, page *int, perPage *int, orderBy string)) *RPCClient_TxSearch_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(bool), args[3].(*int), args[4].(*int), args[5].(string))
	})
	return _c
}

func (_c *RPCClient_TxSearch_Call) Return(_a0 *coretypes.ResultTxSearch, _a1 error) *RPCClient_TxSearch_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RPCClient_TxSearch_Call) RunAndReturn(run func(context.Context, string, bool, *int, *int, string) (*coretypes.ResultTxSearch, error)) *RPCClient_TxSearch_Call {
	_c.Call.Return(run)
	return _c
}

// UnconfirmedTxs provides a mock function with given fields: ctx, limit
func (_m *RPCClient) UnconfirmedTxs(ctx context.Context, limit *int) (*coretypes.ResultUnconfirmedTxs, error) {
	ret := _m.Called(ctx, limit)

	if len(ret) == 0 {
		panic("no return value specified for UnconfirmedTxs")
	}

	var r0 *coretypes.ResultUnconfirmedTxs
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *int) (*coretypes.ResultUnconfirmedTxs, error)); ok {
		return rf(ctx, limit)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *int) *coretypes.ResultUnconfirmedTxs); ok {
		r0 = rf(ctx, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultUnconfirmedTxs)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *int) error); ok {
		r1 = rf(ctx, limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RPCClient_UnconfirmedTxs_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnconfirmedTxs'
type RPCClient_UnconfirmedTxs_Call struct {
	*mock.Call
}

// UnconfirmedTxs is a helper method to define mock.On call
//   - ctx context.Context
//   - limit *int
func (_e *RPCClient_Expecter) UnconfirmedTxs(ctx interface{}, limit interface{}) *RPCClient_UnconfirmedTxs_Call {
	return &RPCClient_UnconfirmedTxs_Call{Call: _e.mock.On("UnconfirmedTxs", ctx, limit)}
}

func (_c *RPCClient_UnconfirmedTxs_Call) Run(run func(ctx context.Context, limit *int)) *RPCClient_UnconfirmedTxs_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*int))
	})
	return _c
}

func (_c *RPCClient_UnconfirmedTxs_Call) Return(_a0 *coretypes.ResultUnconfirmedTxs, _a1 error) *RPCClient_UnconfirmedTxs_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RPCClient_UnconfirmedTxs_Call) RunAndReturn(run func(context.Context, *int) (*coretypes.ResultUnconfirmedTxs, error)) *RPCClient_UnconfirmedTxs_Call {
	_c.Call.Return(run)
	return _c
}

// Unsubscribe provides a mock function with given fields: ctx, subscriber, query
func (_m *RPCClient) Unsubscribe(ctx context.Context, subscriber string, query string) error {
	ret := _m.Called(ctx, subscriber, query)

	if len(ret) == 0 {
		panic("no return value specified for Unsubscribe")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, subscriber, query)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RPCClient_Unsubscribe_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Unsubscribe'
type RPCClient_Unsubscribe_Call struct {
	*mock.Call
}

// Unsubscribe is a helper method to define mock.On call
//   - ctx context.Context
//   - subscriber string
//   - query string
func (_e *RPCClient_Expecter) Unsubscribe(ctx interface{}, subscriber interface{}, query interface{}) *RPCClient_Unsubscribe_Call {
	return &RPCClient_Unsubscribe_Call{Call: _e.mock.On("Unsubscribe", ctx, subscriber, query)}
}

func (_c *RPCClient_Unsubscribe_Call) Run(run func(ctx context.Context, subscriber string, query string)) *RPCClient_Unsubscribe_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *RPCClient_Unsubscribe_Call) Return(_a0 error) *RPCClient_Unsubscribe_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RPCClient_Unsubscribe_Call) RunAndReturn(run func(context.Context, string, string) error) *RPCClient_Unsubscribe_Call {
	_c.Call.Return(run)
	return _c
}

// UnsubscribeAll provides a mock function with given fields: ctx, subscriber
func (_m *RPCClient) UnsubscribeAll(ctx context.Context, subscriber string) error {
	ret := _m.Called(ctx, subscriber)

	if len(ret) == 0 {
		panic("no return value specified for UnsubscribeAll")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, subscriber)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RPCClient_UnsubscribeAll_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnsubscribeAll'
type RPCClient_UnsubscribeAll_Call struct {
	*mock.Call
}

// UnsubscribeAll is a helper method to define mock.On call
//   - ctx context.Context
//   - subscriber string
func (_e *RPCClient_Expecter) UnsubscribeAll(ctx interface{}, subscriber interface{}) *RPCClient_UnsubscribeAll_Call {
	return &RPCClient_UnsubscribeAll_Call{Call: _e.mock.On("UnsubscribeAll", ctx, subscriber)}
}

func (_c *RPCClient_UnsubscribeAll_Call) Run(run func(ctx context.Context, subscriber string)) *RPCClient_UnsubscribeAll_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *RPCClient_UnsubscribeAll_Call) Return(_a0 error) *RPCClient_UnsubscribeAll_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *RPCClient_UnsubscribeAll_Call) RunAndReturn(run func(context.Context, string) error) *RPCClient_UnsubscribeAll_Call {
	_c.Call.Return(run)
	return _c
}

// Validators provides a mock function with given fields: ctx, height, page, perPage
func (_m *RPCClient) Validators(ctx context.Context, height *int64, page *int, perPage *int) (*coretypes.ResultValidators, error) {
	ret := _m.Called(ctx, height, page, perPage)

	if len(ret) == 0 {
		panic("no return value specified for Validators")
	}

	var r0 *coretypes.ResultValidators
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *int64, *int, *int) (*coretypes.ResultValidators, error)); ok {
		return rf(ctx, height, page, perPage)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *int64, *int, *int) *coretypes.ResultValidators); ok {
		r0 = rf(ctx, height, page, perPage)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*coretypes.ResultValidators)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *int64, *int, *int) error); ok {
		r1 = rf(ctx, height, page, perPage)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RPCClient_Validators_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Validators'
type RPCClient_Validators_Call struct {
	*mock.Call
}

// Validators is a helper method to define mock.On call
//   - ctx context.Context
//   - height *int64
//   - page *int
//   - perPage *int
func (_e *RPCClient_Expecter) Validators(ctx interface{}, height interface{}, page interface{}, perPage interface{}) *RPCClient_Validators_Call {
	return &RPCClient_Validators_Call{Call: _e.mock.On("Validators", ctx, height, page, perPage)}
}

func (_c *RPCClient_Validators_Call) Run(run func(ctx context.Context, height *int64, page *int, perPage *int)) *RPCClient_Validators_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*int64), args[2].(*int), args[3].(*int))
	})
	return _c
}

func (_c *RPCClient_Validators_Call) Return(_a0 *coretypes.ResultValidators, _a1 error) *RPCClient_Validators_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *RPCClient_Validators_Call) RunAndReturn(run func(context.Context, *int64, *int, *int) (*coretypes.ResultValidators, error)) *RPCClient_Validators_Call {
	_c.Call.Return(run)
	return _c
}

// NewRPCClient creates a new instance of RPCClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewRPCClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *RPCClient {
	mock := &RPCClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
